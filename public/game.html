<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Crisis Management Game</title>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  <script type="module" src="/js/static-scenarios.js"></script>
  <script src="/js/theme.js"></script>
</head>
<body>

  <!-- HEADER -->
  <div class="header">
    <img src="/images/bank-logo.png" alt="SSBTX Logo">
    <div class="title">
      Crisis Management Game
      <span style="font-size:12px;background:#d3f9d8;color:#2b8a3e;padding:2px 6px;border-radius:6px;margin-left:8px;">
        Live
      </span>
    </div>
  </div>

  <!-- SCOREBOARD (ALWAYS VISIBLE) -->
  <div id="scoreboard" class="scoreboard"></div>

  <!-- SCENARIO -->
  <div class="scenario-box">
    <h2 id="scenarioTitle">Scenario</h2>
    <p id="scenarioText">Loading scenario...</p>
  </div>

  <!-- QUESTION AREA -->
  <div id="questionBox" class="question-box"></div>

  <!-- CONTROLS -->
  <div class="controls">
    <button id="genBtn">Generate New Crisis Scenario</button>
    <button onclick="window.location.href='index.html'">Back to Home</button>
  </div>

<script>
/* ================================
   GAME STATE
================================ */
// When true, reveal points and color hints on selected choice
const REVEAL_POINTS = true;
const DEPARTMENTS = [
  "CEO/SVPs","IT/Security","HR",
  "Finance","Loans","Accounting","Deposits"
];

// Shared colors per department for scoreboard and question label
const DEPT_COLORS = {
  "CEO/SVPs":"#8e44ad",
  "IT/Security":"#c0392b",
  "HR":"#2980b9",
  "Finance":"#27ae60",
  "Loans":"#f39c12",
  "Accounting":"#9b59b6",
  "Deposits":"#2ecc71"
};

const state = {
  scenario: null,
  index: 0,
  answered: false,
  scores: {},
  tiebreaker: false,
  tiedDepts: []
};

DEPARTMENTS.forEach(d => state.scores[d] = 0);

/* ================================
   HELPERS
================================ */
const $ = id => document.getElementById(id);

function escapeHtml(s) {
  return String(s ?? "").replace(/[&<>"']/g, m =>
    ({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m])
  );
}

// Fisher–Yates shuffle to randomize choice order each render
function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function formatPoints(score) {
  const s = Number(score) || 0;
  return (s > 0 ? "+" + s : String(s)) + " pts";
}

function scoreClass(score) {
  const s = Number(score) || 0;
  if (s >= 8) return "good";
  if (s >= 4) return "ok";
  return "bad";
}

function scoreTagline(score) {
  const s = Number(score) || 0;
  if (s >= 8) return "Strong, defensible action that best supports incident goals.";
  if (s >= 4) return "Reasonable choice with some trade-offs; improves the situation.";
  return "Risky or non-compliant action—may worsen impact or create issues.";
}

// Create a fair, round-robin order of questions where
// each department appears at most once per round until its
// questions are exhausted. Order inside each round is randomized.
function roundRobinOrder(questions) {
  const byDept = new Map();
  (questions || []).forEach(q => {
    const d = q.department || 'Unknown';
    if (!byDept.has(d)) byDept.set(d, []);
    byDept.get(d).push(q);
  });

  // Shuffle questions within each department
  for (const [dept, list] of byDept.entries()) {
    byDept.set(dept, shuffle(list));
  }

  const depts = Array.from(byDept.keys());
  const rounds = Math.max(0, ...Array.from(byDept.values()).map(v => v.length));
  const ordered = [];

  for (let r = 0; r < rounds; r++) {
    const thisRound = [];
    for (const d of depts) {
      const list = byDept.get(d);
      if (r < list.length) thisRound.push(list[r]);
    }
    // Randomize order within the round
    ordered.push(...shuffle(thisRound));
  }

  return ordered;
}

/* ================================
   SCOREBOARD
================================ */
function renderScoreboard() {
  $("scoreboard").innerHTML = DEPARTMENTS.map(d => `
    <div class="department" style="background:${DEPT_COLORS[d]}">
      ${d}
      <div class="score" id="score-${d}">${state.scores[d]}</div>
    </div>
  `).join("");
}

/* ================================
   LOAD SCENARIO
================================ */
async function loadScenario() {
  const scenarioEl = $("scenarioText");
  const box = $("questionBox");
  scenarioEl.textContent = "Loading scenario...";
  box.innerHTML = `<div class="loader"><div class="spinner"></div></div>`;

  try {
    // Load locally without API
    const mod = await import('/js/static-scenarios.js');
    const scenario = mod.getRandomScenario();

    // Enforce fair round-robin ordering so each group
    // gets one question before any group gets a second.
    if (Array.isArray(scenario?.questions)) {
      scenario.questions = roundRobinOrder(scenario.questions);
    }

    state.scenario = scenario;
    state.index = 0;
    state.answered = false;
    DEPARTMENTS.forEach(d => state.scores[d] = 0);

    renderScoreboard();

    $("scenarioTitle").textContent = scenario.title || "Scenario";
    $("scenarioText").textContent = scenario.description || "";

    renderQuestion();
  } catch (err) {
    const msg = err?.message || 'Failed to load scenario.';
    box.innerHTML = `
      <div class="uc-box">
        <h3>Couldn\'t load a scenario</h3>
        <p>${msg}</p>
        <div style="margin-top:12px">
          <button onclick="loadScenario()">Try Again</button>
        </div>
      </div>
    `;
  }
}

/* ================================
   RENDER QUESTION
================================ */
function renderQuestion() {
  const q = state.scenario.questions[state.index];
  state.answered = false;

  $("questionBox").innerHTML = `
    <div class="q-progress">
      Question ${state.index + 1} / ${state.scenario.questions.length}
    </div>

    <div class="question-card">
      <div class="department-label" style="background:${DEPT_COLORS[q.department]}; color:#fff">${q.department}</div>
      <h2 class="question-title">${escapeHtml(q.questionText)}</h2>

      <div class="choices">
        ${shuffle(q.choices).map((c,i) => `
          <button class="choice-btn"
            data-score="${c.score}"
            data-reason="${escapeHtml(c.reason)}"
            title="${escapeHtml(c.text)}"
            onclick="pickAnswer(this,'${q.department}')">
            ${escapeHtml(c.text)}
          </button>
        `).join("")}
      </div>

      <div id="reasonBox" class="hidden"></div>

      <div class="next-button">
        <button id="nextBtn" disabled onclick="nextQuestion()">Next Question</button>
      </div>
    </div>
  `;
}

/* ================================
   ANSWER HANDLING
================================ */
function pickAnswer(btn, dept) {
  if (state.answered) return;
  state.answered = true;

  document.querySelectorAll(".choice-btn").forEach(b => b.disabled = true);

  const score = Number(btn.dataset.score);
  const reason = btn.dataset.reason;
  // Show selection feedback; hide explicit points unless REVEAL_POINTS
  const badge = document.createElement('span');
  if (REVEAL_POINTS) {
    badge.className = `point-badge ${scoreClass(score)}`;
    badge.textContent = formatPoints(score);
  } else {
    badge.className = 'point-badge neutral';
    badge.textContent = 'Selected';
  }
  btn.appendChild(badge);

  state.scores[dept] += score;
  $(`score-${dept}`).textContent = state.scores[dept];

  const rb = $("reasonBox");
  rb.classList.remove("hidden");
  if (REVEAL_POINTS) {
    rb.innerHTML = `
      <div class="explain-box">
        <div class="explain-top">
          <span class="point-badge ${scoreClass(score)}">${formatPoints(score)}</span>
          <span class="explain-dept">${dept}</span>
        </div>
        <div class="explain-text">${escapeHtml(reason)}</div>
        <div class="explain-tagline">${scoreTagline(score)}</div>
      </div>
    `;
  } else {
    rb.innerHTML = `
      <div class="explain-box">
        <div class="explain-top">
          <span class="point-badge neutral">Selected</span>
          <span class="explain-dept">${dept}</span>
        </div>
        <div class="explain-text">Thank you. Discuss briefly why this choice may help and any trade-offs to consider.</div>
      </div>
    `;
  }

  const nb = $("nextBtn");
  nb.disabled = false;
  nb.classList.remove("hidden");
}

/* ================================
   NEXT QUESTION
================================ */
async function nextQuestion() {
  state.index++;
  if (state.index >= state.scenario.questions.length) {
    await checkTiebreakerOrEnd();
  } else {
    renderQuestion();
  }
}

/* ================================
   END GAME
================================ */
async function checkTiebreakerOrEnd() {
  const standings = Object.entries(state.scores).sort((a,b)=>b[1]-a[1]);
  const topScore = standings[0]?.[1] ?? 0;
  const atThirty = standings.filter(([_,score]) => score === 30).map(([dept]) => dept);

  if (!state.tiebreaker && topScore === 30 && atThirty.length > 1) {
    state.tiebreaker = true;
    state.tiedDepts = atThirty;
    await startTiebreakerRound(atThirty);
  } else {
    endGame(standings);
  }
}

async function startTiebreakerRound(depts) {
  const mod = await import('/js/static-scenarios.js');
  const scenarios = mod.getScenarios();

  const pickForDept = (dept) => {
    const pool = [];
    scenarios.forEach(s => {
      (s.questions||[]).forEach(q => { if (q.department === dept) pool.push(q); });
    });
    const q = pool[Math.floor(Math.random()*pool.length)];
    const choices = Array.isArray(q?.choices) ? shuffle(q.choices) : [];
    return { ...q, choices };
  };

  const tQuestions = depts.map(d => pickForDept(d));
  const ordered = shuffle(tQuestions);

  $("scenarioTitle").textContent = "Tiebreaker Round";
  $("scenarioText").textContent = "Multiple groups are tied at 30 points. Each tied group gets one extra question.";

  state.scenario = { title: "Tiebreaker Round", description: "", questions: ordered };
  state.index = 0;

  renderQuestion();
}

function endGame(standings) {
  const payload = {
    scenarioTitle: state.scenario?.title || "",
    standings: standings || Object.entries(state.scores).sort((a,b)=>b[1]-a[1]),
    scores: state.scores,
    wasTiebreaker: state.tiebreaker,
    tiedDepts: state.tiedDepts
  };
  try {
    sessionStorage.setItem('cmgResults', JSON.stringify(payload));
  } catch (_) {}
  window.location.href = 'results.html';
}

// Simple confetti animation
function launchConfetti(duration = 2000) {
  const canvas = document.getElementById('confettiCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const box = document.getElementById('questionBox');
  const rect = box.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;

  const colors = ['#ff6b6b','#feca57','#1dd1a1','#54a0ff','#5f27cd'];
  const particles = Array.from({ length: 160 }, () => ({
    x: Math.random()*canvas.width,
    y: -20 - Math.random()*100,
    vx: (Math.random()-0.5)*2,
    vy: 2 + Math.random()*3,
    size: 2 + Math.random()*4,
    rot: Math.random()*Math.PI,
    vr: (Math.random()-0.5)*0.2,
    color: colors[Math.floor(Math.random()*colors.length)]
  }));

  let start = null;
  function frame(ts) {
    if (!start) start = ts;
    const elapsed = ts - start;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    particles.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.rot += p.vr;
      if (p.y > canvas.height + 20) {
        p.y = -20;
        p.x = Math.random()*canvas.width;
      }
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot);
      ctx.fillStyle = p.color;
      // draw small rectangle confetti
      ctx.fillRect(-p.size, -p.size/2, p.size*2, p.size);
      ctx.restore();
    });

    if (elapsed < duration) {
      requestAnimationFrame(frame);
    } else {
      // fade out quickly
      let alpha = 1;
      const fade = () => {
        alpha -= 0.08;
        ctx.globalAlpha = Math.max(alpha, 0);
        ctx.clearRect(0,0,canvas.width,canvas.height);
        if (alpha > 0) requestAnimationFrame(fade);
        else ctx.globalAlpha = 1;
      };
      requestAnimationFrame(fade);
    }
  }
  requestAnimationFrame(frame);
}

/* ================================
   BOOT
================================ */
document.getElementById("genBtn").addEventListener("click", loadScenario);
loadScenario();
</script>

<!-- Choice text is now plausibly rewritten at source (static-scenarios.js). -->

</body>
</html>
